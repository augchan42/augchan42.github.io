---
layout: post
title: "FIDO2 Passkeys for Android: Backend Battles in Python"
author: "Aug"
date: 2025-05-14
header-style: text
catalog: true
description: "A backend developer's journey through the challenges of implementing FIDO2 passkeys for an Android app using Python, covering assetlinks.json, data serialization, and Base64URL encoding."
tags:
  - python
  - fido2
  - passkeys
  - webauthn
  - backend
  - android
  - security
  - fastapi
---

# Implementing FIDO2 Passkeys for Android: A Backend Developer's Journey

Integrating FIDO2 passkeys into an application can significantly enhance security and user experience. However, the journey, especially on the backend, can be fraught with subtle challenges. This post is the first of two detailing my experiences implementing passkey support for an Android (Kotlin) frontend with a Python backend. Here, I'll focus on the backend hurdles I encountered and how I navigated them.

## Key Challenges & Solutions

### 1. The `assetlinks.json` Maze: Verification is Key

One of the first and most critical pieces for making passkeys work with an Android app is the Digital Asset Links file (`assetlinks.json`).

**The Problem:** FIDO2 and WebAuthn rely heavily on `assetlinks.json` to verify the association between your web service (the Relying Party ID) and your native Android application. If this isn't configured perfectly, passkey operations like creation will fail, often with unhelpful generic errors on the client, such as "No create options available."

**My Journey:**

- I started by adding the initial `assetlinks.json`.
- Things got tricky when I switched to a new development machine, which meant a new certificate fingerprint. This required an update to `assetlinks.json`, highlighting the need to manage fingerprints for all relevant build and signing configurations (debug, release, different development machines).
- I further refined the file by cleaning up unused entries. It's crucial that only necessary associations are present. A key learning here was that _each specific app variant_ (e.g., `demo.debug` vs. `debug` vs. `release`) needs its own entry if its package name or signing certificate differs.

> Getting `assetlinks.json` right is your first major checkpoint. Test it thoroughly for all app variants and build configurations. Small mistakes here cascade into significant headaches down the line.

You can typically host this file at `/.well-known/assetlinks.json` on your domain.

### 2. The `UnicodeDecodeError` Saga: Serializing Binary Data

FIDO2 operations involve a lot of binary data. Getting this data from a Python backend to a JSON-consuming client requires careful handling.

**The Problem:** FIDO2 libraries generate options (for registration and authentication) containing binary data, such as the `challenge` and credential `id`s. When these options are sent as JSON from a Python backend (I was using FastAPI), this binary data _must_ be encoded into a string format. The standard here is Base64URL. If you fail to do this, or use the wrong Base64 variant (e.g., standard Base64 instead of Base64URL), you'll likely encounter `UnicodeDecodeError` when the JSON serializer (like Pydantic in FastAPI) tries to process raw bytes.

**My Journey:**

- This issue first bit me during the implementation of registration and recovery flows. The fix involved ensuring consistent Base64URL encoding.
- Later, the same problem resurfaced for login flows, emphasizing that this encoding step needs to be applied universally wherever FIDO2 option objects are prepared for API responses.

**The Solution Involved Two Main Parts:**

**Part 1: Converting FIDO2 Objects to Dictionaries**
The Python objects generated by FIDO2 libraries (e.g., `PublicKeyCredentialCreationOptions` or `PublicKeyCredentialRequestOptions` from `python-fido2`) aren't directly serializable to JSON. They need to be converted to Python dictionaries first.

I developed a pattern to robustly convert these objects:

```python
# In my ChallengeService, when creating authentication options:
# auth_data is a PublicKeyCredentialRequestOptions object from self.server.authenticate_begin(...)

auth_data_as_dict: dict
if hasattr(auth_data, "data") and isinstance(auth_data.data, dict):
    auth_data_as_dict = auth_data.data
elif hasattr(auth_data, "_asdict") and callable(auth_data._asdict):
    auth_data_as_dict = auth_data._asdict()
else:
    try:
        # This is often the most direct way for fido2.webauthn objects
        auth_data_as_dict = dict(auth_data)
    except TypeError:
        # Log a warning and process as is, hoping for the best in the next step.
        # It's much better if conversion to dict succeeds here.
        print(
            f"WARN: Could not convert auth_data of type {type(auth_data)} to dict directly. Processing as is."
        )
        auth_data_as_dict = auth_data # Fallback
```

This approach checks for common attributes like `.data` or methods like `._asdict()` and falls back to a direct `dict()` conversion, which often works for `fido2.webauthn` objects.

**Part 2: Recursive Base64URL Encoding**
Once I had a dictionary, I needed to ensure all `bytes` within it (even in nested structures) were Base64URL encoded. I used a helper function for this:

```python
import base64
from typing import Any

def _process_fido_data_for_json(data: Any) -> Any:
    if isinstance(data, bytes):
        # Use Base64URL encoding and remove padding
        return base64.urlsafe_b64encode(data).decode("utf-8").rstrip("=")
    elif isinstance(data, dict):
        return {k: _process_fido_data_for_json(v) for k, v in data.items()}
    elif isinstance(data, list):
        return [_process_fido_data_for_json(item) for item in data]
    else:
        return data

# Usage in the service:
# auth_data_json = _process_fido_data_for_json(auth_data_as_dict)
# This auth_data_json is now safe to return from a FastAPI endpoint.
```

> **Critical Note:** Always use `base64.urlsafe_b64encode` and `rstrip("=")` for FIDO2. Standard Base64 (`base64.b64encode`) will not work correctly as it can contain characters (`+`, `/`) that are problematic in URLs and some JSON parsers without further escaping.

Serialization is subtle. Converting complex library objects to JSON requires care. Ensure they are fully transformed into basic Python dicts/lists with string-encoded binary data _before_ your web framework's serializer (like FastAPI/Pydantic) sees them.

### 3. Client-Server Ping Pong: Deciphering Error Messages

FIDO2 flows involve multiple interactions between the client and server. Errors can originate on either side, and client-side errors can sometimes be frustratingly cryptic if the root cause is a server-side misstep.

**My Journey:**

- The aforementioned "No create options available" error on Android was a prime example. This led me back to scrutinizing the `assetlinks.json` file and the server-side challenge generation logic.
- Another instance was encountering a `MissingFieldException` on the Android client. This occurred when the server's response to a verification request wasn't structured exactly as the client expected, highlighting the importance of a clear and consistent API contract. Specifically, ensuring the server response always included a `status` field resolved this.

> Client-side error messages can be misleading. It's vital to dig deep. A client error might be a symptom of a server-side problem. Implementing comprehensive logging for server-side request/response details during FIDO2 operations is invaluable for debugging.

## Key Takeaways from the Backend Trenches

Implementing FIDO2 passkeys was a learning curve, but these were some of my main takeaways for the backend portion:

- **`assetlinks.json` is foundational:** Get it right, test it thoroughly, and understand its implications for different app variants and build configurations.
- **Embrace Base64URL:** Understand when and where to encode and decode. Binary data directly in JSON is a recipe for disaster. Always use the URL-safe variant of Base64.
- **Serialization requires diligence:** Ensure FIDO2 library objects are properly converted to JSON-friendly Python dictionaries with all binary data correctly encoded _before_ they hit your API response Pydantic models.
- **Test the full flow relentlessly:** An error in one step (e.g., challenge generation) can manifest in a later step (e.g., during verification).
- **Treat client errors as potential server signals:** Don't just assume the client is wrong. Robust server-side logging and a willingness to investigate server behavior based on client errors are crucial.

Stay tuned for the next post, where I'll dive into the Android (Kotlin) frontend challenges of this passkey implementation journey!

\*\*Disclaimer - Google Gemini 2.5 Pro Exp was used to help write this blog post.
